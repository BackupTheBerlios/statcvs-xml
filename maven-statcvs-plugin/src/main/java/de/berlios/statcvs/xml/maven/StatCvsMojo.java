package de.berlios.statcvs.xml.maven;

/*
 * Copyright 2005 Tammo van Lessen, Steffen Pingel
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import net.sf.statcvs.util.FileUtils;

import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.project.MavenProject;
import org.apache.maven.reporting.AbstractMavenReport;
import org.apache.maven.reporting.MavenReportException;
import org.codehaus.doxia.parser.ParseException;
import org.codehaus.doxia.parser.Parser;
import org.codehaus.doxia.sink.Sink;
import org.codehaus.doxia.site.renderer.SiteRenderer;
import org.codehaus.plexus.util.IOUtil;
import org.codehaus.plexus.util.StringInputStream;
import org.codehaus.plexus.util.StringUtils;

/**
 * Goal which touches a timestamp file.
 *
 * @goal statcvs
 * 
 * @phase process-sources
 */
public class StatCvsMojo extends AbstractMavenReport {

	/**
	 * Location of the file.
	 * @parameter expression="${project.build.directory}/statcvs-xdocs"
	 * @required
	 */
	private File resultsDirectory;

    /**
     * Specifies the directory where the report will be generated
     *
     * @parameter default-value="${project.reporting.outputDirectory}/statcvs"
     * @required
     */
    private File outputDirectory;
    
	/**
     * @component
     * @required
     * @readonly
     */
    private SiteRenderer siteRenderer;
    
    /**
     * @parameter default-value="${project}"
     * @required
     * @readonly
     */
    private MavenProject project;
    
    /**
     * @component roleHint="xdoc"
     */
    private Parser parser;
    
    private Locale locale = Locale.ENGLISH;
    
	public String getOutputName() {
		return "statcvs/index";
	}

	public String getName(Locale locale) {
		//TODO: I18N
		return "StatCvs Report";
	}

	public String getDescription(Locale locale) {
		//TODO: I18N
		return "Statistics about CVS usage generated by StatCvs-XML.";
	}
	
	public boolean canGenerateReport() {
		// TODO: check scm settings ...
		return super.canGenerateReport() && resultsDirectory.exists();
	}

	public boolean isExternalReport() {
		return true;
	}

	protected Sink createSink(String name) throws MavenReportException {
		try {
			return siteRenderer.createSink(outputDirectory, name + ".html",
			        outputDirectory.getAbsolutePath(), getSiteDescriptor(), "maven" );
		} catch (Exception e) {
			throw new MavenReportException("An error has occurred in " + name + " report generation.", e);
		}		
	}
	
	/*
	 * Copied from AbstractMavenReport because the method is not visible. 
	 * TODO: file a jira 
	 */
	public InputStream getSiteDescriptor() throws MojoExecutionException {
		String siteDescriptorContent = "";

		try {
			siteDescriptorContent = IOUtil.toString(AbstractMavenReport.class
					.getResourceAsStream("/default-report.xml"));
		} catch (IOException e) {
			throw new MojoExecutionException( "The site descriptor cannot be read!", e );
		}

		Map props = new HashMap();

		StringBuffer sb = new StringBuffer();
        sb.append("<menu name=\"Project Documentation\">\n");
        sb.append("  <item name=\"" + getName( locale ) + "\" href=\"/" + getOutputName() + ".html\"/>\n");
        sb.append("</menu>\n");

		props.put("reports", sb.toString());

		// TODO: interpolate ${project.*} in general

		if (project.getName() != null) {
			props.put("project.name", project.getName());
		} else {
			props.put("project.name", "NO_PROJECT_NAME_SET");
		}

		if (project.getUrl() != null) {
			props.put("project.url", project.getUrl());
		} else {
			props.put("project.url", "NO_PROJECT_URL_SET");
		}

		siteDescriptorContent = StringUtils.interpolate(siteDescriptorContent,
				props);

		return new StringInputStream(siteDescriptorContent);
	}

	protected SiteRenderer getSiteRenderer() {
		return siteRenderer;
	}

	protected String getOutputDirectory() {
		return outputDirectory.getAbsolutePath();
	}

	protected MavenProject getProject() {
		return project;
	}

	protected void executeReport(Locale locale) throws MavenReportException {
		if (parser != null && resultsDirectory.exists()) {
			File[] files = resultsDirectory.listFiles(new FilenameFilter() {
				public boolean accept(File dir, String name) {
					return name.endsWith(".xml");
				}
			});

			for (File file : files) {
				try {
					Sink fsink = createSink(file.getName());
					Reader r = new FileReader(file);
					parser.parse(r, fsink);
					r.close();
					fsink.close();
				} catch (IOException e) {
					getLog().warn(e);
				} catch (ParseException e) {
					getLog().warn(e);
				}
			}
			
			// copy pngs
			File[] images = resultsDirectory.listFiles(new FilenameFilter() {
				public boolean accept(File dir, String name) {
					return name.endsWith(".png");
				}
			});
			
			for (File file : images) {
				try {
					FileUtils.copyFile(new FileInputStream(file), new File(outputDirectory, file.getName()));
				} catch (IOException e) {
					getLog().warn("Could not copy statistics chart to output folder.");
				}
			}

		} else {
			getLog().info("No CVS statistics found.");
		}
	}
}
